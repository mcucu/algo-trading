//+------------------------------------------------------------------+
//| MA_EMA_Momentum_EA.mq5                                           |
//| Trend-following EMA Crossover + Momentum Filter (RSI / ADX)      |
//+------------------------------------------------------------------+
#property copyright "Generated by ChatGPT"
#property version   "1.00"
#property strict
#include <Trade/Trade.mqh>

CTrade trade;

// ---------- INPUTS ----------
input int    FastEMAPeriod = 20;
input int    SlowEMAPeriod = 50;

input bool   UseRSI       = true;
input int    RSIPeriod    = 14;
input int    RSIThreshold = 50;   // RSI > threshold for LONG, < (100-threshold) for SHORT if symmetric (we use >50/<50 by default)

input bool   UseADX       = false;
input int    ADXPeriod    = 14;
input int    ADXThreshold = 25;   // ADX > threshold means strong trend

// Money Management & Risk
input double RiskPercent  = 1.0;   // percent of balance to risk per trade
input int    StopLossPts  = 400;   // SL in points
input int    TakeProfitPts= 800;   // TP in points

// Trailing
input bool   EnableTrailing = true;
input int    TrailStartPts  = 300;  // start trailing after profit >= points
input int    TrailStepPts   = 150;  // trailing step in points

input int    MagicNumber    = 20251118;

// Misc
input ENUM_TIMEFRAMES TestTimeframe = PERIOD_H1; // for strategy-tester convenience (not strictly necessary)

// ---------- INDICATOR HANDLES ----------
int fastHandle = INVALID_HANDLE;
int slowHandle = INVALID_HANDLE;
int rsiHandle  = INVALID_HANDLE;
int adxHandle  = INVALID_HANDLE;

// Buffers
double fastBuf[2];
double slowBuf[2];
double rsiBuf[1];
double adxBuf[1];

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{
   // create EMA handles
   fastHandle = iMA(_Symbol, _Period, FastEMAPeriod, 0, MODE_EMA, PRICE_CLOSE);
   slowHandle = iMA(_Symbol, _Period, SlowEMAPeriod, 0, MODE_EMA, PRICE_CLOSE);

   if(UseRSI)
      rsiHandle = iRSI(_Symbol, _Period, RSIPeriod, PRICE_CLOSE);

   if(UseADX)
      adxHandle = iADX(_Symbol, _Period, ADXPeriod);

   if(fastHandle == INVALID_HANDLE || slowHandle == INVALID_HANDLE)
   {
      Print("Failed to create EMA handles");
      return INIT_FAILED;
   }
   if(UseRSI && rsiHandle == INVALID_HANDLE)
   {
      Print("Failed to create RSI handle");
      return INIT_FAILED;
   }
   if(UseADX && adxHandle == INVALID_HANDLE)
   {
      Print("Failed to create ADX handle");
      return INIT_FAILED;
   }

   trade.SetExpertMagicNumber((uint)MagicNumber);
   return INIT_SUCCEEDED;
}

//+------------------------------------------------------------------+
//| Helper: check existing position (by magic + type)                |
//+------------------------------------------------------------------+
bool PositionExists(ENUM_POSITION_TYPE type)
{
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket == 0) continue;
      if(PositionSelectByTicket(ticket))
      {
         long pm = PositionGetInteger(POSITION_MAGIC);
         long pt = PositionGetInteger(POSITION_TYPE);
         if(pm == MagicNumber && pt == type) return true;
      }
   }
   return false;
}

//+------------------------------------------------------------------+
//| Money management: calculate lot size based on risk percent       |
//+------------------------------------------------------------------+
double CalculateLotSize(int slPoints)
{
   if(slPoints <= 0) return 0;

   double balance = AccountInfoDouble(ACCOUNT_BALANCE);
   double riskMoney = balance * (RiskPercent / 100.0);

   double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   if(point <= 0) return 0;

   // tick size/value based approach
   double tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
   double tickSize  = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
   double moneyPerLot = 0;

   // fallback if tickValue/tickSize not available
   if(tickValue > 0 && tickSize > 0)
   {
      moneyPerLot = (slPoints * point / tickSize) * tickValue;
   }
   else
   {
      // approximate using contract size * point * price (not exact for all instruments)
      double contractSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_CONTRACT_SIZE);
      double price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
      if(contractSize > 0 && price > 0)
         moneyPerLot = slPoints * point * contractSize * price;
      else
         return 0;
   }

   if(moneyPerLot <= 0) return 0;

   double lots = riskMoney / moneyPerLot;

   // double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   // double maxLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
   // double lotStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
   double minLot = 0.01;
   double maxLot = 0.05;
   double lotStep = 0.01;

   if(lotStep <= 0) lotStep = 0.01;

   // normalize to lotStep
   double steps = MathFloor(lots / lotStep);
   lots = steps * lotStep;

   if(lots < minLot) lots = minLot;
   if(lots > maxLot) lots = maxLot;

   // Ensure at least minLot and valid
   return NormalizeDouble(lots, 2);
}

//+------------------------------------------------------------------+
//| Trailing stop apply                                               |
//+------------------------------------------------------------------+
void ApplyTrailing()
{
   if(!EnableTrailing) return;

   double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   int digits = (int)SymbolInfoInteger(_Symbol, SYMBOL_DIGITS);

   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket == 0) continue;
      if(!PositionSelectByTicket(ticket)) continue;

      long pm = PositionGetInteger(POSITION_MAGIC);
      if(pm != MagicNumber) continue;

      long type = PositionGetInteger(POSITION_TYPE);
      double open = PositionGetDouble(POSITION_PRICE_OPEN);
      double sl = PositionGetDouble(POSITION_SL);
      double cur = (type == POSITION_TYPE_BUY) ? SymbolInfoDouble(_Symbol, SYMBOL_BID) : SymbolInfoDouble(_Symbol, SYMBOL_ASK);

      double profitPts = (type == POSITION_TYPE_BUY) ? (cur - open) / point : (open - cur) / point;
      if(profitPts < TrailStartPts) continue;

      double newSL = (type == POSITION_TYPE_BUY) ? cur - TrailStepPts * point : cur + TrailStepPts * point;
      newSL = NormalizeDouble(newSL, digits);

      // Update only if improvement
      if((type == POSITION_TYPE_BUY && (sl == 0.0 || newSL > sl)) ||
         (type == POSITION_TYPE_SELL && (sl == 0.0 || newSL < sl)))
      {
         trade.PositionModify(ticket, newSL, PositionGetDouble(POSITION_TP));
      }
   }
}

//+------------------------------------------------------------------+
//| Main tick                                                         |
//+------------------------------------------------------------------+
void OnTick()
{
   // safety: re-init if handles invalid
   if(fastHandle == INVALID_HANDLE || slowHandle == INVALID_HANDLE)
   {
      OnInit();
      return;
   }

   // apply trailing first
   ApplyTrailing();

   // copy EMA buffers
   if(CopyBuffer(fastHandle, 0, 0, 2, fastBuf) <= 0) return;
   if(CopyBuffer(slowHandle, 0, 0, 2, slowBuf) <= 0) return;

   double fastNow  = fastBuf[0];
   double fastPrev = fastBuf[1];
   double slowNow  = slowBuf[0];
   double slowPrev = slowBuf[1];

   bool crossUp   = (fastPrev < slowPrev) && (fastNow > slowNow);
   bool crossDown = (fastPrev > slowPrev) && (fastNow < slowNow);

   // momentum filters
   bool rsiOK = true;
   bool adxOK = true;

   if(UseRSI)
   {
      if(CopyBuffer(rsiHandle, 0, 0, 1, rsiBuf) <= 0) return;
      double currRSI = rsiBuf[0];
      // for long require RSI > RSIThreshold, for short require RSI < RSIThreshold
      rsiOK = true; // will be tested at entry time
   }

   if(UseADX)
   {
      if(CopyBuffer(adxHandle, 0, 0, 1, adxBuf) <= 0) return;
      double currADX = adxBuf[0];
      adxOK = (currADX >= ADXThreshold);
   }

   double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   int digits = (int)SymbolInfoInteger(_Symbol, SYMBOL_DIGITS);

   if(bid == 0 || ask == 0 || point == 0) return;

   // LONG ENTRY
   if(crossUp && !PositionExists(POSITION_TYPE_BUY))
   {
      Print("DEBUG | BUY SIGNAL DETECTED");
      // RSI check (if enabled)
      if(UseRSI)
      {
         double currRSI = rsiBuf[0];
         if(currRSI <= RSIThreshold) rsiOK = false;
      }
      else rsiOK = true;

      if(!rsiOK || !adxOK) { /* filters not passed */ }
      else
      {
         double lots = CalculateLotSize(StopLossPts);
         if(lots <= 0) { Print("Lot calculation failed or zero"); }
         else
         {
            double sl = (StopLossPts > 0) ? NormalizeDouble(bid - StopLossPts * point, digits) : 0.0;
            double tp = (TakeProfitPts> 0) ? NormalizeDouble(bid + TakeProfitPts * point, digits) : 0.0;
            if(!trade.Buy(lots, _Symbol, 0.0, sl, tp))
               Print("Buy failed: ", GetLastError());
            else
               Print("Buy opened. lots=", DoubleToString(lots,2), " SL=", DoubleToString(sl,digits), " TP=", DoubleToString(tp,digits));
         }
      }
   }

   // SHORT ENTRY
   if(crossDown && !PositionExists(POSITION_TYPE_SELL))
   {
      Print("DEBUG | SELL SIGNAL DETECTED");
      // RSI check (if enabled)
      if(UseRSI)
      {
         double currRSI = rsiBuf[0];
         if(currRSI >= RSIThreshold) rsiOK = false;
      }
      else rsiOK = true;

      if(!rsiOK || !adxOK) { /* filters not passed */ }
      else
      {
         double lots = CalculateLotSize(StopLossPts);
         if(lots <= 0) { Print("Lot calculation failed or zero"); }
         else
         {
            double sl = (StopLossPts > 0) ? NormalizeDouble(ask + StopLossPts * point, digits) : 0.0;
            double tp = (TakeProfitPts> 0) ? NormalizeDouble(ask - TakeProfitPts * point, digits) : 0.0;
            if(!trade.Sell(lots, _Symbol, 0.0, sl, tp))
               Print("Sell failed: ", GetLastError());
            else
               Print("Sell opened. lots=", DoubleToString(lots,2), " SL=", DoubleToString(sl,digits), " TP=", DoubleToString(tp,digits));
         }
      }
   }
}

//+------------------------------------------------------------------+
