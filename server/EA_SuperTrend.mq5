//+------------------------------------------------------------------+
//| EA_XAUUSD_SuperTrend_M30.mq5                                    |
//| Expert Advisor for XAUUSD on M30                                 |
//| SuperTrend-based entry with RSI, Fibonacci and MA confirmation    |
//+------------------------------------------------------------------+
#property copyright "Generated by ChatGPT"
#property version   "1.02"
#property strict
#include <Trade/Trade.mqh>
CTrade trade;

//------------- INPUTS ------------------------------------------------
input double   RiskPercent = 1.0;            // Risk per trade in percent of account
input double   MinLot = 0.01;                // Minimum lot (also the user's requested fixed lot)
input double   MaxLot = 0.05;                 // Maximum allowed lot
input bool     UseFixedLot = true;          // If true, EA uses FixedLot instead of risk-based sizing
input double   FixedLot = 0.01;              // Fixed lot size per trade if UseFixedLot=true

// SuperTrend inputs
input int      ST_ATR_Period = 10;
input double   ST_Multiplier = 3.0;

// RSI inputs
input int      RSI_Period = 14;
input int      RSI_Buy_Level = 40;           // require RSI > this for buys
input int      RSI_Sell_Level = 60;          // require RSI < this for sells

// MA confirmation
input int      MA_Period = 50;               // Simple MA period

// Fibonacci swing lookback
input int      Fib_Lookback = 100;           // bars to look back for swing high/low
input double   Fib_MinRange = 50;            // minimal range (in points) to consider fib meaningful

// Order management
input double   Slippage = 5;                 // slippage in points
input int      MagicNumber = 20251124;
input double   StopLossBufferPips = 3;       // extra pips beyond computed SL (in points)

// input parameter for max open positions
input int      MaxOpenPositions = 2;         // maximum open positions for this EA (all directions)
input int      CooldownMinutes = 10;

datetime       lastTradeTime = 0;

//-------------- GLOBALS -----------------------------------------------
// (no global loops or conditional statements allowed)

//------------------ Helper functions ----------------------------------
// Convert points to price
double PointsToPrice(double points)
{
   return(points*_Point);
}

// Simple ATR calculation using recent bars
bool CalculateATR(int period,double &atr)
{
   int bars = period + 2;
   double high[]; double low[]; double close[];
   if(CopyHigh(_Symbol,PERIOD_M30,1,bars,high)<=0) return(false);
   if(CopyLow(_Symbol,PERIOD_M30,1,bars,low)<=0) return(false);
   if(CopyClose(_Symbol,PERIOD_M30,1,bars,close)<=0) return(false);
   double trSum=0.0;
   for(int i=0;i<period;i++)
   {
      double curHigh = high[i];
      double curLow  = low[i];
      double prevClose = close[i+1];
      double tr = MathMax(curHigh-curLow, MathMax(MathAbs(curHigh-prevClose), MathAbs(curLow-prevClose)));
      trSum += tr;
   }
   atr = trSum/period;
   return(true);
}

// Get SuperTrend current value and trend direction (lightweight approximation)
bool GetSuperTrend(int atrPeriod,double multiplier,double &stValue,bool &isBull)
{
   double atr=0.0;
   if(!CalculateATR(atrPeriod,atr)) return(false);

   int bars = atrPeriod + 2;
   double high[]; double low[]; double close[];
   if(CopyHigh(_Symbol,PERIOD_M30,1,bars,high)<=0) return(false);
   if(CopyLow(_Symbol,PERIOD_M30,1,bars,low)<=0) return(false);
   if(CopyClose(_Symbol,PERIOD_M30,1,bars,close)<=0) return(false);

   // Build basic bands iteratively
   double finalUpper=0.0, finalLower=0.0;
   bool trendUp=true;
   for(int i=bars-1;i>=0;i--)
   {
      double hl2 = (high[i]+low[i])/2.0;
      double up = hl2 + multiplier*atr;
      double lo = hl2 - multiplier*atr;
      if(i==bars-1)
      {
         finalUpper = up;
         finalLower = lo;
         trendUp = (close[i] >= finalLower);
      }
      else
      {
         if(up < finalUpper || close[i+1] > finalUpper) finalUpper = up;
         if(lo > finalLower || close[i+1] < finalLower) finalLower = lo;
         if(close[i] > finalUpper) trendUp = true;
         else if(close[i] < finalLower) trendUp = false;
      }
   }

   if(trendUp)
   {
      stValue = finalLower;
      isBull = true;
   }
   else
   {
      stValue = finalUpper;
      isBull = false;
   }
   return(true);
}

// Find recent swing high/low over lookback bars
bool GetSwingHighLow(int lookback,double &swingHigh,double &swingLow)
{
   int bars = lookback;
   double highs[]; double lows[];
   if(CopyHigh(_Symbol,PERIOD_M30,1,bars,highs)<=0) return(false);
   if(CopyLow(_Symbol,PERIOD_M30,1,bars,lows)<=0) return(false);
   swingHigh = highs[0];
   swingLow = lows[0];
   for(int i=1;i<bars;i++)
   {
      if(highs[i] > swingHigh) swingHigh = highs[i];
      if(lows[i]  < swingLow)  swingLow  = lows[i];
   }
   return(true);
}

// Calculate lot size based on risk percent and stoploss distance in points
double CalcLotByRisk(double riskPercent,double stoplossPoints)
{
   if(stoplossPoints<=0) return(MinLot);
   double balance = AccountInfoDouble(ACCOUNT_BALANCE);
   double riskAmount = balance * riskPercent/100.0;

   double tickValue = SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_VALUE);
   double tickSize  = SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_SIZE);
   if(tickValue==0 || tickSize==0)
   {
      // fallback approximation
      double approxValuePerPoint = 100.0; // rough for XAUUSD
      double lot = riskAmount / (stoplossPoints * approxValuePerPoint);
      lot = MathMax(lot,MinLot);
      lot = MathMin(lot,MaxLot);
      return(NormalizeDouble(lot,2));
   }
   double valuePerPointPerLot = tickValue/tickSize; // value of 1 point for 1 lot
   double lot = riskAmount / (stoplossPoints * valuePerPointPerLot);
   lot = MathMax(lot,MinLot);
   lot = MathMin(lot,MaxLot);
   return(NormalizeDouble(lot,2));
}

//------------------ OnInit / OnDeinit ---------------------------------
int OnInit()
{
   // nothing heavy - we use Copy* functions inside OnTick
   return(INIT_SUCCEEDED);
}

void OnDeinit(const int reason)
{
}

//------------------ OnTick ------------------------------------------------
void OnTick()
{
   // only proceed if symbol matches typical XAUUSD names (still allow other if attached)
   // get current candle data
   double ask = SymbolInfoDouble(_Symbol,SYMBOL_ASK);
   double bid = SymbolInfoDouble(_Symbol,SYMBOL_BID);
   double price = (ask+bid)/2.0;
   
   if(TimeCurrent() - lastTradeTime < CooldownMinutes * 60)
      return;

   // compute SuperTrend
   double stValue=0; bool isBull=false;
   if(!GetSuperTrend(ST_ATR_Period,ST_Multiplier,stValue,isBull)) return;

   // RSI (handle + CopyBuffer)
   double rsi = 0.0;
   {
      int rsi_handle = iRSI(_Symbol,PERIOD_M30,RSI_Period,PRICE_CLOSE);
      if(rsi_handle>0)
      {
         double rsi_buf[];
         if(CopyBuffer(rsi_handle,0,0,1,rsi_buf)>0) rsi = rsi_buf[0];
         IndicatorRelease(rsi_handle);
      }
   }

   // MA (handle + CopyBuffer)
   double ma = 0.0;
   {
      int ma_handle = iMA(_Symbol,PERIOD_M30,MA_Period,0,MODE_SMA,PRICE_CLOSE);
      if(ma_handle>0)
      {
         double ma_buf[];
         if(CopyBuffer(ma_handle,0,0,1,ma_buf)>0) ma = ma_buf[0];
         IndicatorRelease(ma_handle);
      }
   }

   // Get swing high/low and fibonacci level
   double swingHigh=0.0, swingLow=0.0;
   bool haveSwing = GetSwingHighLow(Fib_Lookback,swingHigh,swingLow);
   double fibRange = (swingHigh - swingLow);

   // Determine fib conditions
   bool fibOkBuy = false; bool fibOkSell = false;
   if(haveSwing && MathAbs(fibRange) > Fib_MinRange*_Point)
   {
      double level382 = swingLow + 0.382*fibRange;
      double level618 = swingLow + 0.618*fibRange; // unused but available
      if(price > level382) fibOkBuy = true; // price above 38.2
      if(price < (swingHigh - 0.382*fibRange)) fibOkSell = true;
   }
   else
   {
      fibOkBuy = fibOkSell = true; // if not meaningful, don't block entries
   }

   // check existing positions for symbol & magic
   int totalPositions = PositionsTotal();
   int myPositions = 0;
   bool hasLong=false, hasShort=false;
   for(int i=0;i<totalPositions;i++)
   {
      if(PositionGetTicket(i)>0)
      {
         ulong ticket = PositionGetTicket(i);
         if(PositionSelectByTicket(ticket))
         {
            if(PositionGetInteger(POSITION_MAGIC)==MagicNumber && PositionGetString(POSITION_SYMBOL)==_Symbol)
            {
               myPositions++;
               long type = PositionGetInteger(POSITION_TYPE);
               if(type==POSITION_TYPE_BUY) hasLong=true;
               if(type==POSITION_TYPE_SELL) hasShort=true;
            }
         }
      }
   }

   // If max open positions reached, do not open new trades
   if(myPositions >= MaxOpenPositions) return;

   // ENTRY: Buy (avoid hedge)
   if(isBull && !hasShort && myPositions < MaxOpenPositions)
   {
      if(rsi > RSI_Buy_Level && price > ma && fibOkBuy)
      {
         double sl = stValue - StopLossBufferPips*_Point;
         double stoplossPoints = (price - sl)/_Point;
         if(stoplossPoints <= 0) return;
         double lot = UseFixedLot ? FixedLot : CalcLotByRisk(RiskPercent,stoplossPoints);
         lot = MathMax(lot,MinLot);
         double takeProfitPrice = price + 2.0*(price - sl);

         trade.SetExpertMagicNumber(MagicNumber);
         trade.SetDeviationInPoints((int)Slippage);
         bool res = trade.Buy(lot, NULL, ask, sl, takeProfitPrice, NULL);
         if(res)
         {
            PrintFormat("[EA] Buy placed: lot=%.2f SL=%.5f TP=%.5f",lot,sl,takeProfitPrice);
            lastTradeTime = TimeCurrent();
         }
         else PrintFormat("[EA] Buy failed, error=%d",GetLastError());
      }
   }

   // ENTRY: Sell (avoid hedge)
   if(!isBull && !hasLong && myPositions < MaxOpenPositions)
   {
      if(rsi < RSI_Sell_Level && price < ma && fibOkSell)
      {
         double sl = stValue + StopLossBufferPips*_Point;
         double stoplossPoints = (sl - price)/_Point;
         if(stoplossPoints <= 0) return;
         double lot = UseFixedLot ? FixedLot : CalcLotByRisk(RiskPercent,stoplossPoints);
         lot = MathMax(lot,MinLot);
         double takeProfitPrice = price - 2.0*(sl - price);

         trade.SetExpertMagicNumber(MagicNumber);
         trade.SetDeviationInPoints((int)Slippage);
         bool res = trade.Sell(lot, NULL, bid, sl, takeProfitPrice, NULL);
         if(res)
         {
            PrintFormat("[EA] Sell placed: lot=%.2f SL=%.5f TP=%.5f",lot,sl,takeProfitPrice);
            lastTradeTime = TimeCurrent();
         }
         else PrintFormat("[EA] Sell failed, error=%d",GetLastError());
      }
   }

}

//+------------------------------------------------------------------+
// Notes:
// - This EA uses an internal SuperTrend approximation. Replace with custom indicator if desired.
// - MaxOpenPositions is an input parameter and anti-hedge logic prevents opposite-direction entries.
// - Test on demo first. If you get runtime errors, share the exact error and line number and I'll fix it.
//+------------------------------------------------------------------+
