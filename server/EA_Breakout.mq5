//+------------------------------------------------------------------+
//| EA Breakout + Volatility Filter for XAUUSD (MQL5) - FINAL v2     |
//+------------------------------------------------------------------+
#property copyright "Generated by ChatGPT"
#property version   "1.03"
#property strict
#include <Trade\Trade.mqh>

input bool   UseTimeFilter       = false;             // Enable/disable time session filter

// Box / session settings
input int    BoxCandles         = 30;                // Number of candles to define the box (20-40 suggested)
input int    BoxStartHour       = 0;                 // Session start hour (server time) for box - set to your broker/server
input int    BoxEndHour         = 7;                 // Session end hour (server time) for box

// Filters
input int    ATR_Period         = 14;                // ATR period
input double ATR_MinPoints      = 60.0;              // Minimum ATR in points (depends on symbol digits)
input double VolumeMultiplier   = 1.3;               // Volume must be >= averageVolume * VolumeMultiplier
input int    VolumeAvgPeriod    = 50;                // Period for average volume
input double MaxSpreadPoints    = 30.0;
input double MaxSpreadATRRatio = 0.15; // spread max = 15% dari ATR (0.1–0.2 ideal)            // Max spread in points to allow trading

// Risk / money management
input double RiskPercent        = 0.5;               // Risk percent per trade (0.5 = 0.5%)
input double FixedLot           = 0.0;               // If >0, use fixed lot size
input double MaxLot             = 5.0;               // Max lot size

// SL / TP / trailing
input int    SL_Buffer_Points   = 40;                // Buffer outside box in points
input double TP_ATR_Multiplier  = 2.0;               // Take profit = ATR * multiplier (if UseFiboTP=false)
input bool   UseFiboTP          = false;             // Use Fibonacci extension instead of ATR
input double FiboExt_Multiplier = 1.618;             // Fibonacci extension multiplier on box range
input double Trailing_ATR_Mult  = 0.8;               // Trailing initial distance in ATR multiples
input int    TrailingLookback    = 20;               // Lookback for HH/HL structure

// Misc
input bool   AllowBuy           = true;
input bool   AllowSell          = true;
input bool   OnlyOnePosition    = true;              // Allow only one position per symbol
input bool   UseBreakEven       = true;              // Move SL to BE after BE_Trigger_ATR * ATR
input double BE_Trigger_ATR     = 1.0;               // Move to break even after price moved this ATR
input int    MagicNumber        = 20251212;
input bool   EnableLogging      = true;

CTrade trade;

//--- global state
double PointValue;
int    DigitsVal;
string TradeSymbol;
ENUM_TIMEFRAMES TF;

//+------------------------------------------------------------------+
int OnInit()
  {
   // symbol and timeframe dynamic
   TradeSymbol = _Symbol;
   TF = (ENUM_TIMEFRAMES)_Period;
   SymbolSelect(TradeSymbol,true);

   // Use out-parameters to be compatible with all MT5 builds/brokers
   double tmpDouble=0;
   long tmpLong=0;
   if(!SymbolInfoDouble(TradeSymbol,SYMBOL_POINT,tmpDouble)) tmpDouble = 0.01;
   PointValue = tmpDouble;
   if(!SymbolInfoInteger(TradeSymbol,SYMBOL_DIGITS,tmpLong)) tmpLong = 5;
   DigitsVal  = (int)tmpLong;

   if(EnableLogging) PrintFormat("EA initialized for %s on TF=%d. Point=%.10f digits=%d",TradeSymbol,TF,PointValue,DigitsVal);
   return(INIT_SUCCEEDED);
  }

//+------------------------------------------------------------------+
void OnTick()
  {
   static datetime lastBarTime=0;
   MqlRates rates[];
   int need = BoxCandles + 120;
   if(CopyRates(TradeSymbol,TF,0,need,rates)<=0)
     {
      if(EnableLogging) Print("Failed to copy rates");
      return;
     }

   // execute logic only on new closed candle
   if(rates[0].time==lastBarTime) return; // no new closed candle
   lastBarTime = rates[0].time;

   // compute box over last BoxCandles that occurred between session hours
   double boxHigh= -1e18, boxLow= 1e18;
   int count=0;
   for(int i=BoxCandles-1;i>=0;i--)
     {
      datetime t = rates[i].time;
      MqlDateTime mt; TimeToStruct(t,mt);
      int hour = mt.hour;
      bool inSession=false;
      if(!UseTimeFilter)
         inSession = true;
      else
        {
         if(BoxStartHour<=BoxEndHour)
            inSession = (hour>=BoxStartHour && hour<BoxEndHour);
         else // wrap
            inSession = (hour>=BoxStartHour || hour<BoxEndHour);
        }
      if(inSession)
        {
         if(rates[i].high>boxHigh) boxHigh=rates[i].high;
         if(rates[i].low<boxLow)   boxLow =rates[i].low;
         count++;
        }
     }
   if(count<5)
     {
      if(EnableLogging) PrintFormat("Not enough candles in defined session to form a box. Count=%d", count);
      return;
     }

   // latest closed candle (index 1) is the last finished candle
   double lastClose = rates[1].close;

   // ATR - use iATR handle + CopyBuffer
   int atrHandle = iATR(TradeSymbol,TF,ATR_Period);
   if(atrHandle==INVALID_HANDLE)
     {
      if(EnableLogging) Print("Failed to create ATR handle");
      return;
     }
   double atrArr[3]; ArrayInitialize(atrArr,0.0);
   if(CopyBuffer(atrHandle,0,0,3,atrArr)<=0)
     {
      if(EnableLogging) Print("Failed to get ATR data");
      IndicatorRelease(atrHandle);
      return;
     }
   double atr = atrArr[0]; // ATR in price units
   IndicatorRelease(atrHandle);

   // average volume
   double avgVol=0; int volCount=0;
   for(int i=1;i<=VolumeAvgPeriod && i<ArraySize(rates);i++)
      {
         avgVol += (double)rates[i].tick_volume;
         volCount++;
      }
   if(volCount>0) avgVol/=volCount; else avgVol=0;
   double lastVol = (double)rates[1].tick_volume;

   // spread (points) using out param
   double ask = SymbolInfoDouble(TradeSymbol, SYMBOL_ASK);
   double bid = SymbolInfoDouble(TradeSymbol, SYMBOL_BID);
   
   if(ask <= 0 || bid <= 0) return;
   
   // spread dalam PRICE
   double spreadPrice = ask - bid;
   
   // ATR juga dalam PRICE → langsung comparable
   double spreadRatio = spreadPrice / atr;
   
   if(spreadRatio > MaxSpreadATRRatio)
   {
      if(EnableLogging)
         PrintFormat("Spread too high vs ATR: ratio=%.2f (max %.2f)", spreadRatio, MaxSpreadATRRatio);
      return;
   }

   // Entry logic: close outside box
   bool breakoutUp = (lastClose>boxHigh);
   bool breakoutDn = (lastClose<boxLow);

   // Volume check
   bool volOK = (avgVol>0) ? (lastVol >= avgVol * VolumeMultiplier) : true;

   // ATR check - ATR_MinPoints is in points -> convert using PointValue
   bool atrOK = (atr >= (ATR_MinPoints * PointValue));

   if(EnableLogging)
     {
      PrintFormat("Box: H=%.2f L=%.2f candles=%d | lastClose=%.2f | ATR=%.5f | spread=%.1f | vol=%.0f avg=%.0f",
                  boxHigh,boxLow,count,lastClose,atr,spreadRatio,lastVol,avgVol);
     }

   // Check existing positions
   int totalPos = CountPositions(TradeSymbol);
   if(OnlyOnePosition && totalPos>0)
     {
      if(EnableLogging) Print("Position exists and OnlyOnePosition=true -> skip new entries");
      // still manage trailing for the existing position
      ManagePositions(atr);
      return;
     }

   // Decide entry
   if(breakoutUp && atrOK && volOK && AllowBuy)
     {
      double sl = boxLow - SL_Buffer_Points * PointValue;
      double tp = 0;
      if(UseFiboTP)
         tp = lastClose + (boxHigh - boxLow) * FiboExt_Multiplier; // basic fib extension
      else
         tp = lastClose + atr * TP_ATR_Multiplier;
      double lot = CalculateLotSize(sl,lastClose);
      if(lot>0)
        {
         SendOrder(ORDER_TYPE_BUY,lot,sl,tp);
        }
     }
   else if(breakoutDn && atrOK && volOK && AllowSell)
     {
      double sl = boxHigh + SL_Buffer_Points * PointValue;
      double tp = 0;
      if(UseFiboTP)
         tp = lastClose - (boxHigh - boxLow) * FiboExt_Multiplier;
      else
         tp = lastClose - atr * TP_ATR_Multiplier;
      double lot = CalculateLotSize(sl,lastClose);
      if(lot>0)
        {
         SendOrder(ORDER_TYPE_SELL,lot,sl,tp);
        }
     }

   // Manage trailing for open positions
   ManagePositions(atr);
  }

//+------------------------------------------------------------------+
int CountPositions(string symbol)
  {
   int count=0;
   int total = PositionsTotal();
   for(int p=0; p<total; p++)
     {
      ulong ticket = PositionGetTicket(p);
      if(!PositionSelectByTicket(ticket)) continue;
      if(PositionGetString(POSITION_SYMBOL)==symbol && PositionGetInteger(POSITION_MAGIC)==MagicNumber) count++;
     }
   return count;
  }

//+------------------------------------------------------------------+
double CalculateLotSize(double sl, double entry)
  {
   // simple fixed lot or risk-based
   double lot=FixedLot;
   if(FixedLot<=0.0001)
     {
      // risk-based calc using SL distance in account currency (approximation)
      double slDistance = MathAbs(entry - sl);
      if(slDistance<=0) return 0.0;

      double tickValue=0;
      if(!SymbolInfoDouble(TradeSymbol,SYMBOL_TRADE_TICK_VALUE,tickValue)) tickValue = 1.0;

      double accountRisk = AccountInfoDouble(ACCOUNT_BALANCE) * RiskPercent / 100.0;
      double pricePoint = PointValue;
      double lossPerLot = (slDistance/pricePoint) * tickValue; // approximate
      if(lossPerLot<=0) return 0.01;
      lot = MathMin(MaxLot, NormalizeDouble(accountRisk / lossPerLot,2));
      double minLot = 0.0;
      if(!SymbolInfoDouble(TradeSymbol,SYMBOL_VOLUME_MIN,tickValue)) minLot = 0.01;
      else minLot = tickValue;
      if(lot<minLot) lot = minLot;
     }
   double minLot=0, maxLot=MaxLot;
   if(!SymbolInfoDouble(TradeSymbol,SYMBOL_VOLUME_MIN,minLot)) minLot = 0.01;
   if(!SymbolInfoDouble(TradeSymbol,SYMBOL_VOLUME_MAX,maxLot)) maxLot = MaxLot;
   lot = MathMax(lot,minLot);
   lot = MathMin(lot,maxLot);
   return(NormalizeDouble(lot,2));
  }

//+------------------------------------------------------------------+
void SendOrder(ENUM_ORDER_TYPE orderType,double volume,double sl,double tp)
  {
   trade.SetExpertMagicNumber(MagicNumber);
   trade.SetDeviationInPoints(50);
   bool res=false;
   if(orderType==ORDER_TYPE_BUY)
     {
      res = trade.Buy(volume,TradeSymbol,0,sl,tp);
     }
   else if(orderType==ORDER_TYPE_SELL)
     {
      res = trade.Sell(volume,TradeSymbol,0,sl,tp);
     }
   if(res)
     {
      if(EnableLogging) PrintFormat("Order placed: %s vol=%.2f sl=%.5f tp=%.5f",OrderTypeToString((int)orderType),volume,sl,tp);
     }
   else
     {
      if(EnableLogging) PrintFormat("Order failed: %s -> %s",OrderTypeToString((int)orderType),trade.ResultRetcodeDescription());
     }
  }

//+------------------------------------------------------------------+
void ManagePositions(double atr)
  {
   int total = PositionsTotal();
   for(int p=0; p<total; p++)
     {
      ulong ticket = PositionGetTicket(p);
      if(!PositionSelectByTicket(ticket)) continue;
      if(PositionGetInteger(POSITION_MAGIC)!=MagicNumber) continue;
      if(PositionGetString(POSITION_SYMBOL)!=TradeSymbol) continue;

      double price = PositionGetDouble(POSITION_PRICE_OPEN);
      double curBid=0, curAsk=0;
      SymbolInfoDouble(TradeSymbol,SYMBOL_BID,curBid);
      SymbolInfoDouble(TradeSymbol,SYMBOL_ASK,curAsk);

      long type = PositionGetInteger(POSITION_TYPE);
      double sl = PositionGetDouble(POSITION_SL);
      double tp = PositionGetDouble(POSITION_TP);

      // Calculate structure highs/lows from recent candles
      MqlRates r[];
      int got = CopyRates(TradeSymbol,TF,1,TrailingLookback,r);
      double highestPrice = -1e18;
      double lowestPrice = 1e18;
      if(got>0)
        {
         for(int k=0;k<got;k++)
           {
            if(r[k].high>highestPrice) highestPrice=r[k].high;
            if(r[k].low<lowestPrice)   lowestPrice  = r[k].low;
           }
        }

      // trailing logic
      if(type==POSITION_TYPE_BUY)
        {
         double newSL = curBid - atr*Trailing_ATR_Mult;
         if(newSL>sl)
           {
            trade.PositionModify(ticket,newSL,tp);
            if(EnableLogging) PrintFormat("Modify BUY ticket %I64u: newSL=%.5f",ticket,newSL);
           }
         // break-even
         if(UseBreakEven)
           {
            double moved = curBid - price;
            if(moved >= BE_Trigger_ATR*atr)
              {
               double be = price + PointValue*2; // small profit buffer
               if(be>sl)
                 {
                  trade.PositionModify(ticket,be,tp);
                  if(EnableLogging) PrintFormat("Set BE BUY ticket %I64u -> %.5f",ticket,be);
                 }
              }
           }
        }
      else if(type==POSITION_TYPE_SELL)
        {
         double newSL = curAsk + atr*Trailing_ATR_Mult;
         if(newSL<sl || sl==0)
           {
            trade.PositionModify(ticket,newSL,tp);
            if(EnableLogging) PrintFormat("Modify SELL ticket %I64u: newSL=%.5f",ticket,newSL);
           }
         // break-even
         if(UseBreakEven)
           {
            double moved = price - curAsk;
            if(moved >= BE_Trigger_ATR*atr)
              {
               double be = price - PointValue*2;
               if(be<sl || sl==0)
                 {
                  trade.PositionModify(ticket,be,tp);
                  if(EnableLogging) PrintFormat("Set BE SELL ticket %I64u -> %.5f",ticket,be);
                 }
              }
           }
        }
     }
  }

//+------------------------------------------------------------------+
string OrderTypeToString(int t)
  {
   if(t==ORDER_TYPE_BUY) return("BUY");
   if(t==ORDER_TYPE_SELL) return("SELL");
   return(IntegerToString(t));
  }

//+------------------------------------------------------------------+
// Helper: Copy recent tick volumes - simple wrapper (not precise for all brokers)
int CopyTicksVolume(string symbol,long &out[],int start,int count)
  {
   ArrayResize(out,count);
   MqlRates rates[];
   int got = CopyRates(symbol,TF,0,count+start,rates);
   if(got<=0) return -1;
   for(int i=0;i<count;i++) out[i] = rates[i+start].tick_volume;
   return count;
  }

//+------------------------------------------------------------------+
// On deinit
void OnDeinit(const int reason)
  {
   if(EnableLogging) Print("EA deinitialized");
  }
//+------------------------------------------------------------------+
